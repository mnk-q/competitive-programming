{
	// Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Testcase" : {
		"prefix": "testcase",
		"body": [
			"for t in range(int(input())):",
			"\t$0"
		]
	},
	"Multiple Inputs" : {
		"prefix": "multiple",
		"body": "map(int, input().split())"
	},
	"Array Input" :{
		"prefix": "listinput",
		"body": "list(map(int, input().split()))"	
	},

	"Fast IO": {
		"prefix": "fastio",
		"body": [
		  "from __future__ import division, print_function",
		  "",
		  "import os",
		  "import sys",
		  "from io import BytesIO, IOBase",
		  "from collections import defaultdict,Counter, deque",
		  "from math import *",
		  "from heapq import heapify, heappush, heappop",
		  "if sys.version_info[0] < 3:",
		  "\tfrom __builtin__ import xrange as range",
		  "\tfrom future_builtins import ascii, filter, hex, map, oct, zip",
		  "",
		  "############################################################################",
		  "#                           ACTUAL CODE",
		  "############################################################################",
		  "",
		  "def solve(t):",
		  "    $0",
		  "  ",
		  "",
		  "",
		  "def main():",
		  "\ttc = int(input().strip())",
		  "\tfor t in range(1, tc+1):",
		  "\t\tprint(solve(t))",
		  "",
		  "#'''",
		  "############################################################################",
		  "#                         FAST-IO",
		  "#                         PyRIVAL",
		  "############################################################################",
		  "",
		  "BUFSIZE = 8192",
		  "",
		  "",
		  "class FastIO(IOBase):",
		  "\tnewlines = 0",
		  "",
		  "\tdef __init__(self, file):",
		  "\t	self._fd = file.fileno()",
		  "\t	self.buffer = BytesIO()",
		  "\t	self.writable = \"x\" in file.mode or \"r\" not in file.mode",
		  "\t	self.write = self.buffer.write if self.writable else None",
		  "",
		  "\tdef read(self):",
		  "\t	while True:",
		  "\t		b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
		  "\t		if not b:",
		  "\t			break",
		  "\t		ptr = self.buffer.tell()",
		  "\t		self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
		  "\t	self.newlines = 0",
		  "\t	return self.buffer.read()",
		  "",
		  "\tdef readline(self):",
		  "\t	while self.newlines == 0:",
		  "\t		b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
		  "\t		self.newlines = b.count(b\"\\n\") + (not b)",
		  "\t		ptr = self.buffer.tell()",
		  "\t		self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
		  "\t	self.newlines -= 1",
		  "\t	return self.buffer.readline()",
		  "",
		  "\tdef flush(self):",
		  "\t	if self.writable:",
		  "\t		os.write(self._fd, self.buffer.getvalue())",
		  "\t		self.buffer.truncate(0), self.buffer.seek(0)",
		  "",
		  "",
		  "class IOWrapper(IOBase):",
		  "\tdef __init__(self, file):",
		  "\t	self.buffer = FastIO(file)",
		  "\t	self.flush = self.buffer.flush",
		  "\t	self.writable = self.buffer.writable",
		  "\t	self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))",
		  "\t	self.read = lambda: self.buffer.read().decode(\"ascii\")",
		  "\t	self.readline = lambda: self.buffer.readline().decode(\"ascii\")",
		  "",
		  "",
		  "def print(*args, **kwargs):",
		  "\t\"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"",
		  "\tsep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)",
		  "\tat_start = True",
		  "\tfor x in args:",
		  "\t	if not at_start:",
		  "\t		file.write(sep)",
		  "\t	file.write(str(x))",
		  "\t	at_start = False",
		  "\tfile.write(kwargs.pop(\"end\", \"\\n\"))",
		  "\tif kwargs.pop(\"flush\", False):",
		  "\t	file.flush()",
		  "",
		  "",
		  "if sys.version_info[0] < 3:",
		  "\tsys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)",
		  "else:",
		  "\tsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)",
		  "",
		  "input = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")",
		  "",
		  "############################################################################",
		  "''' # '''",
		  "",
		  "",
		  "## DRIVER # PROGRAM ########################################################",
		  "if __name__ == \"__main__\":",
		  "\tmain()"
		],
		"description": "Fast IO"
	},
	"Imports" :{
		"prefix": "init",
		"body": [
			"from collections import Counter, defaultdict, deque",
			"from math import ceil,floor,sqrt,log2",
			"md=1000000007",
			"md2=998244353",
			"mx=1000000000",
			"mx2=1e18",
			"\n$0"
		],
		"description": "Initial Imports and Declarations"
	},
	"Binary Search": {
		"prefix": "binarysearch",
		"body": [
		  "def binary_search(arr, key):",
		  "    k=0",
		  "    n=len(arr)",
		  "    b=n//2",
		  "    while b>=1:",
		  "        while (k+b)< n and arr[k+b]<=key:",
		  "            k+=b ",
		  "        b=b>>1",
		  "    if arr[k]==key:",
		  "        return k",
		  "    return -1"
		],
		"description": "Binary Search"
	  },
	  "Floor Value": {
		"prefix": "getfloor",
		"body": [
		  "def getFloor(nums, x, index=False):",
		  " ",
		  "    (left, right) = (0, len(nums) - 1)",
		  "    floor = -1",
		  "    floorIndex=-1",
		  "    while left <= right:",
		  "        mid = (left + right) // 2",
		  "        if nums[mid] == x:",
		  "            return nums[mid]",
		  "        elif x < nums[mid]:",
		  "            right = mid - 1",
		  "        else:",
		  "            floor = nums[mid]",
		  "            floorIndex = mid",
		  "            left = mid + 1",
		  "    if index:",
		  "        return floorIndex",
		  "    return floor",
		  ""
		],
		"description": "Floor Value"
	  },
	  "Ceil Value": {
		"prefix": "getceil",
		"body": [
		  "def getCeil(nums, x, index=False):",
		  "    (left, right) = (0, len(nums) - 1)",
		  "    ceil = -1",
		  "    ceilIndex = -1",
		  "    while left <= right:",
		  "        mid = (left + right) // 2",
		  "        if nums[mid] == x:",
		  "            return nums[mid]",
		  "        elif x < nums[mid]:",
		  "            ceil = nums[mid]",
		  "            ceilIndex = mid",
		  "            right = mid - 1",
		  "        else:",
		  "            left = mid + 1",
		  "    if index:",
		  "        return ceilIndex",
		  "    return ceil"
		],
		"description": "Ceil Value"
	  },
	  

 }